using System.Runtime.InteropServices;

namespace Opereators
{
    internal class Program
    {
        static void Main(string[] args)
        {
            int a = 14;
            int b = 6;
            int c = 0;
            //산술 연산자
            //------------------------------------------------------------------

            c = a + b; // a + b 연산 후 c메모리(변수)에다가 결과값(데이터)을 쓰겠다
            Console.WriteLine(c);
            c = a - b;
            Console.WriteLine(c);
            c = a * b;
            Console.WriteLine(c);
            c = a / b;//정수끼리 나눗셈은 몫만 반환(소수점을 반올림 안하고 버림)
            Console.WriteLine(c);
            c = a % b;//나머지 연산..
            Console.WriteLine(c);

            //복합 대입 연산자
            //------------------------------------------------------------------

            c += a;// c = c + a;와 같다
            c -= a;
            c *= a;
            c /= a;
            c %= a;

            //증감 연산자
            //------------------------------------------------------------------

            //전위 연산자
            //연산 내용 : c = c + 1;
            //반환값 : c + 1;
            ++c; // c = c + 1;, c += c; 와 같다
            --c; // c = c - 1;, c -= c; 와 같다
            //후위 연산자
            //연산 내용 : c = c + 1;
            //반환값 : c;
            c++;
            c--;

            // 관계 연산자
            // 두 피연산자의 관계를 비교해서 결과가 참인지 거짓인지 반환
            // ---------------------------------------------------------------
            bool result;
            result = a == b;// a 와 b가 같으면 true , 아니면 false
            result = a != b;
            result = a > c;
            result = a >= c;
            result = a < c;
            result = a <= c;

            //논리 연산자 
            //논리형의 피연산자들에 대해서만 연산 수행
            //-----------------------------------------------------------------
            bool A = true;
            bool B = false;

            //or
            //A와 B 둘 중에 하나라도 true면 true, 아니면 false
            result = A | B;

            //and
            //A와 B 둘다 true일 때만 true, 아니면 false
            result = A & B;

            //xor
            //A와 B둘 중에 하나만 true면 true, 아니면 false
            result = A ^ B;

            //not
            //A가 true이면 false, false 이면 true
            result = !A;
            result = A == false;

            //조건부 논리 연산
            //------------------------------------------------------
            
            // conditional or
            //A가 true이면 논리 연산 수행하지 않고 true 반환 아니면 A | B 수행
            result = A || B;

            //conditional and
            //A가 false이면 논리 연산 수행하지 않고 false 반환 아니면 A & B 수행
            result = A && B;

            //비트 연산자
            //정수형에 대해서만 연산함
            //-------------------------------------------------------

            //or
            Console.WriteLine(a|b);
            // a == 14 == 2^3 + 2^2 + 2^1 => 00001110
            //b == 6 == 2^2 + 2^1 =>         00000110
            //----------------------------------------or 둘 중 하나만 1이여도 된다
            //result == ...00001110 == 14

            //and
            Console.WriteLine(a & b);
            // a == 14 == 2^3 + 2^2 + 2^1 => 00001110
            //b == 6 == 2^2 + 2^1 =>         00000110
            //----------------------------------------and 둘 다 1이여야 한다 
            //result == ...00000110 == 6

            //xor
            Console.WriteLine(a ^ b);
            // a == 14 == 2^3 + 2^2 + 2^1 => 00001110
            //b == 6 == 2^2 + 2^1 =>         00000110
            //----------------------------------------xor 둘 중에 한개만 1이여야 한다
            //result == ...00001000 == 8

            //not
            Console.WriteLine(~ a);
            // a == 14 == 2^3 + 2^2 + 2^1 => 00000000 00000000 00000000 00001110
            //----------------------------------------not 2보수 로 반전 +1
            //result == 11111111 11111111 11111111 11110001 == -15

            //2의 보수 : 2진수 모든 자리 반전 후 +1 == ~a + 1
            // a == 14 == 00000000 00000000 00000000 00001110
            // -a == -14 == 11111111 11111111 11111111 11110010
            // -a * -1 == 14 == 00000000 00000000 00000000 00001110

            //shift -left
            //비트를 n자리만큼 왼쪽으로 밀어라
            Console.WriteLine(a << 2);
            // a == 14 == 2^3 + 2^2 + 2^1 => 00000000 00000000 00000000 00001110
            //----------------------------------------<<2
            //result == 00000000 00000000 00000000 00111000 = 56


            //shift -right
            //비트를 n자리만큼 오른쪽으로 밀어라
            Console.WriteLine(a >> 2);
            // a == 14 == 2^3 + 2^2 + 2^1 => 00000000 00000000 00000000 00001110
            //---------------------------------------->>2
            //result == 00000000 00000000 00000000 00000011 = 3

            //bit flag mask

            //Layers
            //0 : ground
            //1 : player
            //2 : emeny
            //3 : prop

            //ground checking mask : 00000000 00000000 00000000 00000001
            //어떤 객체가 감지되었을 때 땅인지 보려면
            //해당 객체의 bitflag 값과 mask를 & 연산

        }

        public class Collider
        {
            public int layer;
            public int collisionMask; //00000000 00000000 00000000 00001001

            public void OnCollisionEnter(Collider other)
            {
                //enemy
                //00000000 00000000 00000000 00000100
                //00000000 00000000 00000000 00001001
                //-----------------------------------&
                //00000000 00000000 00000000 00000000

                //prop
                //00000000 00000000 00000000 00001000
                //00000000 00000000 00000000 00001001
                //-----------------------------------&
                //00000000 00000000 00000000 00001000

                if (((1 << other.layer) & collisionMask) > 0)
                {
                    //something to do when collision occurerd
                }
            }
        }


        //ref 키워드
        //파라미터를 주소 참조 타입으로 쓰겠다는 키워드 -> 즉, 여기 인자로 넣어줄 수 있는건 주소를 가지고 있는 변수 같은 메모리 영역을 넣어줘야함.(상수X)
        int AfterPP(ref int variable)
        {
            int origin = variable;
            variable += 1;
            return origin;
        }
        int BeforePP(ref int variable)
        {
            variable += 1;
            return variable;
        }
    }
}