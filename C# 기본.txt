1 주차
객체 선정 : 
추상화 : 
클래스화 : 어떤 객체를 만들려면 어떤 종류의, 얼마만큼의 메모리를 할당해야하는지와 어떤 기능이 있는지 정의한다
객체화 : 
컴파일 : 다른언어체계로 번역하는 과정
컴파일러 : 컴파일 프로그램
어셈블리어 : 1:1 매핑으로 컴파일을 빠르게 해준다
가상머신 : 개발자가 놓치기 쉬운 부분들을 알아서 처리해주는 기계
intermidiate Langauge : 가상머신의 기능과 1:1 매핑되는 언어
HDD : 파일들이 저장됨
CPU : 메모리의 값을 읽어 연산 후 결과를 출력
(*중요*) 병목현상 : 메모리 정보 속도와  CPU 처리속도간의 차이에 의해 나타나는 현상
RAM : HDD에 실해 프로그램을 검색하고 RAM에 복사한다(현재 실행 중인 프로그램 내에서만 검색하면 되기 때문에 불필요한 데이터 탐색이 없어진다, 전송속도는 HDD보다 빠름)
Cache : Cache의 데이터 전송 속도는 RAM보다 빠르다 인접한 데이터를 어느 크기(이게 캐쉬라인)만큼 복제해놓기 때문에 CPU에서 전체 RAM을 탐색해야 하는 경우를 줄여준다
- 캐쉬 히트 캐시라인 단위(대부분 64바이트)로 읽은 데이터에서 필요한 데이터를 찾음
- 캐쉬 미스 : 캐쉬라인 단위(대부분 64바이트)로 읽은 데이터에서 필요한 데이터를 못 찾음
bit : 정보 처리의 최소 단위 (0, 1이 있음)
byte : 데이터의 최소 묶음 단위(8bit) bit를 묶어서 한번에 처리
{"여기서부터는 내지역이다"라는 표시} : 중괄호
함수 : f(x) = ax + b
인수(인자(Arqument)) : 어떤 결과에 영향을 끼치는 것
함수 이름 : f
입력(매개 변수 = parameter) : x
함수 연산 내용 : ax+ b
Data type (자료형) 자주 사용될만한 자료들에 대해서 미리 정의해놓은 형태
int : 부호가 있는 정수형(4byte)
long : 부호가 있는 정수형(8byte)
uint : 부호가 없는 정수형(4byte)
ulong : 부호가 없는 정수형(8byte)
short : 부호가 있는 정수형(2byte)
ushort : 부호가 있는 정수형(2byte)
char : 문자형(2byte) - ASCII코드표에 따름
float : 실수형(4byte)
double : 실수형(8byte)
bool : 논리형(1byte)(0이면 거짓, 0이 아니면 참)
작은 자료형에서 큰 자료형(암시적 캐스팅)으로 빠꾸는 것은 가능하나 반대는 안된다
어떤 자료형을  더 큰 동일형태의 자료형으로 읽는 것은 가능(자료형의 승격)
더 작은 크기의 자료형으로 읽는 것은 명시하지 않으면 불가능(자료 손실이 일어나기 때문)
2의 보수 : 모든 비트 반전 후 +1
2주차
(선생님이 나오지 않고 있어 다른 쌤이 들어와서 unity나 취업, 입시에 대해 얘기한다하고 수업이 1시간 지속될 시 수업이 없는 것을로 본다
선생님 약 1시 40분 도착 후 시작 8시에 끝날 예정)
객체지향형 프로그래밍 : 
객체 : (어떤 사물, 사념을 나타내지만) 프로그램에서는 어떤 사물이나 사념을 만들기 위해 확보한 특정한 공간
초기화 : 확보한 메모리 공간에 값을 처음 넣는 과정(메모리안에 뭐가 있는지 모르니까 "초기화"한다)
인스턴스 : 초기화가 된 객체 
사용자 정의 자료형 : 개발자가 직접 얼마만큼의 메모리를 어떻게 할당해야하는지 정의할 수 있는 자료형
클래스 : 멤버들을 가지고 어떤 변수가 필요하다고 정의하면 해당 변수를 멤버로 가지게 된다
멤버 변수 : 사용자 정의 자료형에서 특정 공간능 구성하는 구성원으로 정의된 변수(함수는 멤버로 포함하지 않는다)
RAM은 Code, BSS, Data, Heap, Stack가 있는데 클래스 타입 객체는 Heap에 만들어짐, 컴파일이 된 코드는 Code에 할당됨(함수가 여기에 할당됨),
처음 프로그램 인스턴스가 할당될 때 모든 비트가 0으로 Reset되는 것을 BSS (정적 변수, 전역 변수 데이터(초기;값을 명시하지 않은 경우))
정적 변수, 전역 변수 데이터(초기값을 명시했을 경우) Data이다
클래스 생성자 : Heap영역에다가 클래스 타입의 객체를 할당
Mathod : 객체를 통해 호출되는 함수
함수 : f(x) = ax + b
인수 : 어떤 결과에 영향을 끼치는 것
함수 이름 : f
입력(매개 변수 = parameter) : x
함수 연산 내용 : ax+ b
프로그래밍에서는
반환형 f(매개 변수의 자료형 x)
{
   ax + b
   return;
}
반환형 f(매개 변수의 자료형 x)
{
   return ax + b;
}
함수 호출 : Code에 함수를 찾아서 복사해 Stack영역에 할당하고 매개(매개체) 변수 영역에는 인자로 전달한 값을 대입함
return : 이함수가 차지하고 있던 메모리 영역에 제어권을 시스템에다가 반환하겠다는 명령어
void : 반환 타입이 정해져 있지않음(반환타입 x)
지역변수 : {} 내에서 정의되어 해당 연산 중에만 메모리에 할당되는 변수(파라미터도 지역변수의 일종)
if구문 : 
if(논리형의실행조건)
{
    샐행조건이 참일때 실핼할 내용
}
else
{
   실행조건이 거짓일 떄
}
전역 변수 : 어떤 클래스에서도 접근 가능한 변수(클래스의 멤버 변수도 전역변수이다)
클래스 소멸자 : 해당 객체가 할당된 메모리 영역을 시스템 반환하는 함수(하지만 거의 사용하지 않는다) 
CLR이 Managed Heap 영역을 매번 순회 -> GC ROOT(가비지 컬렉션 대상 목록) -> Garbage Collacter가 해당 목록에서 사용되지 않는 메모리를 해제시도 이래서 굳이 소멸자를 쓸 필요가 없음
함수 호출 스텍 : Code에 있는 함수를 복제해 Stack영역에 쌓고 그안에 또 함수가 있으면 아래 함수를 기억했하고 다시 Code에서 복제해 Stack을 쌓는다
일렬의 작업과정을 분리해서 개별적으로 할 수 있게 끔 하는 처리과정이 Thread이다
클래스는 캡슐화를 컨셉으로 한 사용자 정의 자료형이다
생성된 객체의 주소를 반환
값 타입 vs 참조 타입
값 타입 : 데이터를 직접 메모리에 쓰고 읽는 타입
참조 타입 : 특정 메모리 주소를 통해 간접적으로 해당 메모리에 데이터를 쓰고 읽는 타입
포인터 타입 : 메모리 주소를 쓰고 읽는 타입(C#에서는 unsafe 코드작성 외에 쓰지않음)
new : 동적 할당 키워드 메모리를 동적으로 할당하겠다고 명시할 때 사용하는 키워드
접근 제한자 (Access Modifier) : 외부에서 멤버 접근 가능여부를 제한하는 키워드
private - 이 클래스 말고 다른 클래스는 해당 멤버 클래스에 접근할 수 없다(- 로 표현) 
protected - 이 클래스를 상속 받은 자식클래스만 해당 멤버에 접근할 수 있다(#)
intermal - Assembly(코드조각, exe, dll 등) 단위로만 해당 멤버에 접근할 수 있다
public - 접근제한 없음.
promotion(승격)
크기가 더 큰 자료형 레지스터로 작은 데이터를 읽었을 때
읽는 과정에서 해당 데이터의 자료형이 바꿔는 효과