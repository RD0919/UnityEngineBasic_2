1 주차
객체 선정 : 
추상화 : 
클래스화 : 어떤 객체를 만들려면 어떤 종류의, 얼마만큼의 메모리를 할당해야하는지와 어떤 기능이 있는지 정의한다
객체화 : 
컴파일 : 다른언어체계로 번역하는 과정
컴파일러 : 컴파일 프로그램
어셈블리어 : 1:1 매핑으로 컴파일을 빠르게 해준다
가상머신 : 개발자가 놓치기 쉬운 부분들을 알아서 처리해주는 기계
intermidiate Langauge : 가상머신의 기능과 1:1 매핑되는 언어
HDD : 파일들이 저장됨
CPU : 메모리의 값을 읽어 연산 후 결과를 출력
(*중요*) 병목현상 : 메모리 정보 속도와  CPU 처리속도간의 차이에 의해 나타나는 현상
RAM : HDD에 실해 프로그램을 검색하고 RAM에 복사한다(현재 실행 중인 프로그램 내에서만 검색하면 되기 때문에 불필요한 데이터 탐색이 없어진다, 전송속도는 HDD보다 빠름)
Cache : Cache의 데이터 전송 속도는 RAM보다 빠르다 인접한 데이터를 어느 크기(이게 캐쉬라인)만큼 복제해놓기 때문에 CPU에서 전체 RAM을 탐색해야 하는 경우를 줄여준다
- 캐쉬 히트 캐시라인 단위(대부분 64바이트)로 읽은 데이터에서 필요한 데이터를 찾음
- 캐쉬 미스 : 캐쉬라인 단위(대부분 64바이트)로 읽은 데이터에서 필요한 데이터를 못 찾음
bit : 정보 처리의 최소 단위 (0, 1이 있음)
byte : 데이터의 최소 묶음 단위(8bit) bit를 묶어서 한번에 처리
{"여기서부터는 내지역이다"라는 표시} : 중괄호
함수 : f(x) = ax + b
인수(인자(Arqument)) : 어떤 결과에 영향을 끼치는 것
함수 이름 : f
입력(매개 변수 = parameter) : x
함수 연산 내용 : ax+ b
Data type (자료형) 자주 사용될만한 자료들에 대해서 미리 정의해놓은 형태
int : 부호가 있는 정수형(4byte)
long : 부호가 있는 정수형(8byte)
uint : 부호가 없는 정수형(4byte)
ulong : 부호가 없는 정수형(8byte)
short : 부호가 있는 정수형(2byte)
ushort : 부호가 있는 정수형(2byte)
char : 문자형(2byte) - ASCII코드표에 따름
float : 실수형(4byte)
double : 실수형(8byte)
bool : 논리형(1byte)(0이면 거짓, 0이 아니면 참)
작은 자료형에서 큰 자료형(암시적 캐스팅)으로 빠꾸는 것은 가능하나 반대는 안된다
어떤 자료형을  더 큰 동일형태의 자료형으로 읽는 것은 가능(자료형의 승격)
더 작은 크기의 자료형으로 읽는 것은 명시하지 않으면 불가능(자료 손실이 일어나기 때문)
2의 보수 : 모든 비트 반전 후 +1
2주차
(선생님이 나오지 않고 있어 다른 쌤이 들어와서 unity나 취업, 입시에 대해 얘기한다하고 수업이 1시간 지속될 시 수업이 없는 것을로 본다
선생님 약 1시 40분 도착 후 시작 8시에 끝날 예정)
객체지향형 프로그래밍 : 
객체 : (어떤 사물, 사념을 나타내지만) 프로그램에서는 어떤 사물이나 사념을 만들기 위해 확보한 특정한 공간
초기화 : 확보한 메모리 공간에 값을 처음 넣는 과정(메모리안에 뭐가 있는지 모르니까 "초기화"한다)
인스턴스 : 초기화가 된 객체 
사용자 정의 자료형 : 개발자가 직접 얼마만큼의 메모리를 어떻게 할당해야하는지 정의할 수 있는 자료형
클래스 : 멤버들을 가지고 어떤 변수가 필요하다고 정의하면 해당 변수를 멤버로 가지게 된다
멤버 변수 : 사용자 정의 자료형에서 특정 공간능 구성하는 구성원으로 정의된 변수(함수는 멤버로 포함하지 않는다)
RAM은 Code, BSS, Data, Heap, Stack가 있는데 클래스 타입 객체는 Heap에 만들어짐, 컴파일이 된 코드는 Code에 할당됨(함수가 여기에 할당됨),
처음 프로그램 인스턴스가 할당될 때 모든 비트가 0으로 Reset되는 것을 BSS (정적 변수, 전역 변수 데이터(초기;값을 명시하지 않은 경우))
정적 변수, 전역 변수 데이터(초기값을 명시했을 경우) Data이다
클래스 생성자 : Heap영역에다가 클래스 타입의 객체를 할당
Mathod : 객체를 통해 호출되는 함수
함수 : f(x) = ax + b
인수 : 어떤 결과에 영향을 끼치는 것
함수 이름 : f
입력(매개 변수 = parameter) : x
함수 연산 내용 : ax+ b
프로그래밍에서는
반환형 f(매개 변수의 자료형 x)
{
   ax + b
   return;
}
반환형 f(매개 변수의 자료형 x)
{
   return ax + b;
}
함수 호출 : Code에 함수를 찾아서 복사해 Stack영역에 할당하고 매개(매개체) 변수 영역에는 인자로 전달한 값을 대입함
return : 이함수가 차지하고 있던 메모리 영역에 제어권을 시스템에다가 반환하겠다는 명령어
void : 반환 타입이 정해져 있지않음(반환타입 x)
지역변수 : {} 내에서 정의되어 해당 연산 중에만 메모리에 할당되는 변수(파라미터도 지역변수의 일종)
if구문 : 
if(논리형의실행조건)
{
    샐행조건이 참일때 실핼할 내용
}
else
{
   실행조건이 거짓일 떄
}
전역 변수 : 어떤 클래스에서도 접근 가능한 변수(클래스의 멤버 변수도 전역변수이다)
클래스 소멸자 : 해당 객체가 할당된 메모리 영역을 시스템 반환하는 함수(하지만 거의 사용하지 않는다) 
CLR이 Managed Heap 영역을 매번 순회 -> GC ROOT(가비지 컬렉션 대상 목록) -> Garbage Collacter가 해당 목록에서 사용되지 않는 메모리를 해제시도 이래서 굳이 소멸자를 쓸 필요가 없음
함수 호출 스텍 : Code에 있는 함수를 복제해 Stack영역에 쌓고 그안에 또 함수가 있으면 아래 함수를 기억했하고 다시 Code에서 복제해 Stack을 쌓는다
일렬의 작업과정을 분리해서 개별적으로 할 수 있게 끔 하는 처리과정이 Thread이다
클래스는 캡슐화를 컨셉으로 한 사용자 정의 자료형이다
생성된 객체의 주소를 반환
값 타입 vs 참조 타입
값 타입 : 데이터를 직접 메모리에 쓰고 읽는 타입
참조 타입 : 특정 메모리 주소를 통해 간접적으로 해당 메모리에 데이터를 쓰고 읽는 타입
포인터 타입 : 메모리 주소를 쓰고 읽는 타입(C#에서는 unsafe 코드작성 외에 쓰지않음)
new : 동적 할당 키워드 메모리를 동적으로 할당하겠다고 명시할 때 사용하는 키워드
접근 제한자 (Access Modifier) : 외부에서 멤버 접근 가능여부를 제한하는 키워드
private - 이 클래스 말고 다른 클래스는 해당 멤버 클래스에 접근할 수 없다(- 로 표현) 
protected - 이 클래스를 상속 받은 자식클래스만 해당 멤버에 접근할 수 있다(#)
intermal - Assembly(코드조각, exe, dll 등) 단위로만 해당 멤버에 접근할 수 있다
public - 접근제한 없음.
promotion(승격)
크기가 더 큰 자료형 레지스터로 작은 데이터를 읽었을 때
읽는 과정에서 해당 데이터의 자료형이 바꿔는 효과
3일차 
Unity와 c#을 같이 쓰며 진행한다 고 애기함
오늘 배울 연산자는 Unity에서 해도 상관없기 때문에 스크립트로만 한다 함
Global : 메모리 영역에 누구나 접근할 수 있다
Static : 한번만 할당하고 추가적인 할당을 할 수 없다
Local : 지역변수 그 지역에서만 사용됨.
Casting (명시적) : 8byte 메모리가 4byte가 될 때 데이터 손실이 있어 코드에 명시해줘야 되는 타입
Casting (암시적) : 4byte 메모리를 8byte로 바뀔 때는 데이터 손실이 없어 코드에 명시하지 않아도 됨 (promotion)
mathods : 객체단위로 호출
Class : 특징과 기능을 가진 정의
등 전 내용을 복습함
식별 문자 : 네임 스페이스에 메모리를 탐색하기 위해서 쓰는 식별 문자
using : 어떤 namespace를 갖다 쓰겠다고 명시하는 키워드(어떤 네임스페이스의 클래스를 디폴트로 사용하겠다고 명시하는 구문)\
연산자 : 더하기, 빼기, 곱하기, 나누기 등
+ : 더하기
- : 빼기
* : 곱하기
/ : 나누기(소수점은 반올림 안 하고 그냥 버림)
% : 나머지
복합 대입 연산자
c+= : c = c + a;
c-= : c = c - a;
c*= : c = c * a;
c/= : c = c / a;
c%= : c = c % a;
전위 연산자 : 연산 후 반환하는 코드
++c
--c
후위 연산자 : 반환후 연산하는 코드
c++
c--
관계 연산자 : 두연산자의 관계를 비교해서 결과가 참인지 거짓인지 반환 (bool이여야만 함)
a == b; : a와 b가 같으면 true, 아니면 false
a != b; : a가 b와 다르면 true, 아니면 false
a >b
  <b
  >=b  : 대소 비교
  <=b
논리 연산자
 | : or
 & : and
 ^ : xor
 ! : not
조건부 논리 연산
conditional or : A가 true이면 논리 연산 수행하지 않고 true 반환 아니면 A | B 수행
A || B
conditional and : A가 false이면 논리 연산 수행하지 않고 false 반환 아니면 A & B 수행
A && B
.비트 연산자(정수형만 연산함)
a == 14 == 2^3 + 2^2 + 2^1 => 00001110
b == 6 == 2^2 + 2^1 =>           00000110
CW(a|b); : 둘 중 하나만 1이여도 된다 == ...00001110 == 14
CW(a&b); : 둘 다 1이여야 된다 == ...00000110 == 6
CW(a^b); : 둘 중에 한개만 1이여야 한다 == ...00001000 == 8
 a => 00000000 00000000 00000000 00001110 
CW(~a); : 2보수 로 반전 +1 => 11111111 11111111 11111111 11110001 == -15
shift - left : 비트를 n자리만큼 왼쪽으로 밀어라 =>  00000000 00000000 00000000 00111000 = 56
shift - right : 비트를 n자리만큼 오른쪽으로 밀어라 => 00000000 00000000 00000000 00000011 = 3
ref 키워드
파라미터를 주소 참조 형태로 쓰겠다는 키워드 -> 즉, 여기 인자로 넣어줄 수 있는건 주소를 가지고 있는 변수 같은 메모리 영역을 넣어줘야함.(상수X)
4주차
시험 때문에 못 나옴
5주차
전 시간에 
switch
enum
대리자 (Delegate) : 함수의 주소를 참조하는 타입, 함수체이닝(함수뒤에 계속 다른 함수를 연결) 구현 가능, 호출 시에 등록된 모든 함수를 차례대로 호출 해줌
(유튜버와 구독자로 비유)
event 한정자
외부에서는 이 대리자의 += 과 -=만 사용가능하도록 제한
등을 했다 함
Serialize : 데이터를 텍스트로, Deserialize : 텍스트를 데이터로